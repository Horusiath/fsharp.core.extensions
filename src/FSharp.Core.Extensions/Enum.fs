(*

Copyright 2019 Bartosz Sypytkowski

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*)

/// Utility functions that enable traverse function helpers over IEnumerator-like elements.
[<RequireQualifiedAccess>]
module FSharp.Core.Enum

open System.Collections.Generic
open System.Runtime.CompilerServices

let inline ofSeq (x: #seq<'a>) = x.GetEnumerator()

let inline from<'a, 'e, ^T when 'e :> IEnumerator<'a> and ^T: (member GetEnumerator: unit -> 'e)> (x: ^T) =
    (^T: (member GetEnumerator: unit -> 'e) (x))

/// Iterates over the elements generated by enumerator `e`, executing given function `fn`
/// over every single one of them. Disposes given enumerator.
let inline iter<'e, 'a when 'e :> IEnumerator<'a>> (fn: 'a -> unit) (e: 'e) =
    use mutable e2 = e
    while e2.MoveNext() do
        fn e2.Current
        
/// Iterates over the elements generated by enumerator `e`, applying accumulating
/// function `fn` over current element and a result of previous iteration (starting
/// with `init` as an initial value).
///
/// Returns `init` if enumerator didn't return any elements.
/// This function disposes provided enumerator.
let inline fold<'e, 'a, 'b when 'e :> IEnumerator<'a>> (fn: 'b -> 'a -> 'b) (init: 'b) (e: 'e) =
    use mutable e2 = e
    let mutable state = init
    while e2.MoveNext() do
        state <- fn state e2.Current
    state
    
/// Iterates over the elements generated by enumerator `e`, applying accumulating
/// function `fn` over current element and a result of previous iteration (starting
/// with the first element returned from a given enumerator).
///
/// Returns ValueNone, if enumerator didn't provide any elements.
/// This function disposes provided enumerator. 
let reduce<'e, 'a when 'e :> IEnumerator<'a>> (fn: 'a -> 'a -> 'a) (e: 'e) =
    use mutable e2 = e
    if e2.MoveNext() then
        let mutable state = e2.Current
        while e2.MoveNext() do
            state <- fn state e2.Current
        ValueSome state
    else ValueNone
    
/// Returns first value of the enumerator or ValueNone if enumerator didn't produce any value.
/// This function disposes provided enumerator. 
let inline tryHead<'e, 'a when 'e :> IEnumerator<'a>> (e: 'e) =
    use mutable e2 = e
    if e2.MoveNext() then
        ValueSome e2.Current
    else ValueNone
    
/// Returns the last value of the enumerator or ValueNone if enumerator didn't produce any value.
/// This function disposes provided enumerator. 
let tryLast<'e, 'a when 'e :> IEnumerator<'a>> (e: 'e) =
    use mutable e2 = e
    if e2.MoveNext() then
        let mutable last = e2.Current
        while e2.MoveNext() do last <- e2.Current
        ValueSome last
    else ValueNone

/// Counts the number of elements produced by a given enumerator
let count<'e, 'a when 'e :> IEnumerator<'a>> (e: 'e) =
    let mutable i = 0L
    use mutable e2 = e
    while e2.MoveNext() do i <- i + 1L
    i
    
[<Struct>]
type FilterEnumerator<'e, 'a when 'e :> IEnumerator<'a>> =
    val mutable private enumerator: 'e
    val private predicate: 'a -> bool
    new(enumerator: 'e, predicate: 'a -> bool) =
        { enumerator = enumerator; predicate = predicate }
    member this.Current = this.enumerator.Current
    
    [<MethodImpl(MethodImplOptions.AggressiveInlining)>]
    member this.MoveNext() =
        let mutable satisfied = false
        while not satisfied && this.enumerator.MoveNext() do
            satisfied <- this.predicate this.enumerator.Current
        satisfied
    interface IEnumerator<'a> with
        member this.Current: 'a = this.Current
        member this.Current: obj = upcast this.Current
        member this.Reset() = this.enumerator.Reset()
        member this.Dispose() = this.enumerator.Dispose()
        member this.MoveNext(): bool = this.MoveNext()

/// Wraps provided enumerator `e` with another one, which will skip
/// generation of `e`'s elements, which didn't pass expected predicate `fn`.    
let inline filter<'e, 'a when 'e :> IEnumerator<'a>> (fn: 'a -> bool) (e: 'e) = new FilterEnumerator<_,_>(e, fn)

[<Struct>]
type MapEnumerator<'e, 'a, 'b when 'e :> IEnumerator<'a>> =
    val mutable private enumerator: 'e
    val mutable private current: 'b
    val private mapper: 'a -> 'b
    new(enumerator: 'e, mapper: 'a -> 'b) =
        { enumerator = enumerator; mapper = mapper; current = Unchecked.defaultof<_> }
    member this.Current = this.current
    
    [<MethodImpl(MethodImplOptions.AggressiveInlining)>]
    member this.MoveNext(): bool =
        if this.enumerator.MoveNext() then
            this.current <- this.mapper this.enumerator.Current
            true
        else false
    interface IEnumerator<'b> with
        member this.Current: 'b = this.Current
        member this.Current: obj = upcast this.Current
        member this.Reset() = this.enumerator.Reset()
        member this.Dispose() = this.enumerator.Dispose()
        member this.MoveNext(): bool = this.MoveNext()

/// Wraps provided enumerator `e` with another one, which will map every of the `e`'s elements into new value,
/// using a mapping function `fn`. Elements mapped this way are cached, so multiple calls to `enumerator.Current`
/// will always return the same value.
let inline map<'e, 'a, 'b when 'e :> IEnumerator<'a>> (fn: 'a -> 'b) (e: 'e) = new MapEnumerator<_,_,_>(e, fn) 

[<Struct>]
type ChooseEnumerator<'e, 'a, 'b when 'e :> IEnumerator<'a>> =
    val mutable private enumerator: 'e
    val mutable private current: 'b
    val private mapper: 'a -> 'b option
    new(enumerator: 'e, mapper: 'a -> 'b option) =
        { enumerator = enumerator; mapper = mapper; current = Unchecked.defaultof<_> }
    member this.Current = this.current    
    member this.MoveNext(): bool =
        let mutable found = false
        while not found && this.enumerator.MoveNext() do
            match this.mapper this.enumerator.Current with
            | Some value ->
                this.current <- value
                found <- true
            | _ -> ()
        found
        
    interface IEnumerator<'b> with
        member this.Current: 'b = this.Current
        member this.Current: obj = upcast this.Current
        member this.Reset() = this.enumerator.Reset()
        member this.Dispose() = this.enumerator.Dispose()
        member this.MoveNext(): bool = this.MoveNext()

/// Wraps provided enumerator `e` with another one, which will filter and map every of the `e`'s elements into new value,
/// using a mapping function `fn` and skipping all elements, for which this function result is None. Elements mapped
/// this way are cached, so multiple calls to `enumerator.Current` will always return the same value.      
let inline choose<'e, 'a, 'b when 'e :> IEnumerator<'a>> (fn: 'a -> 'b option) (e: 'e) = new ChooseEnumerator<_,_,_>(e, fn)

[<Struct>]
type SkipEnumerator<'e, 'a when 'e :> IEnumerator<'a>> =
    val mutable private enumerator: 'e
    val mutable private countdown: int64
    new(enumerator: 'e, countdown: int64) =
        { enumerator = enumerator; countdown = countdown }
    member this.Current = this.enumerator.Current    
    member this.MoveNext(): bool =
        if this.countdown = 0L
        then this.enumerator.MoveNext()
        else
            let mutable ok = this.enumerator.MoveNext()
            while ok && this.countdown > 0L do
                this.countdown <- this.countdown - 1L
                ok <- this.enumerator.MoveNext()
            ok
        
    interface IEnumerator<'a> with
        member this.Current: 'a = this.Current
        member this.Current: obj = upcast this.Current
        member this.Reset() = this.enumerator.Reset()
        member this.Dispose() = this.enumerator.Dispose()
        member this.MoveNext(): bool = this.MoveNext()
        
let inline skip<'e, 'a, 'b when 'e :> IEnumerator<'a>> (count: int64) (e: 'e) = new SkipEnumerator<_,_>(e, count)

[<Struct>]
type TakeEnumerator<'e, 'a when 'e :> IEnumerator<'a>> =
    val mutable private enumerator: 'e
    val mutable private countdown: int64
    new(enumerator: 'e, countdown: int64) =
        { enumerator = enumerator; countdown = countdown }
    member this.Current = this.enumerator.Current    
    member this.MoveNext(): bool =
        if this.countdown > 0L then
            this.countdown <- this.countdown - 1L
            this.enumerator.MoveNext()
        else false
        
    interface IEnumerator<'a> with
        member this.Current: 'a = this.Current
        member this.Current: obj = upcast this.Current
        member this.Reset() = this.enumerator.Reset()
        member this.Dispose() = this.enumerator.Dispose()
        member this.MoveNext(): bool = this.MoveNext()
        
let inline take<'e, 'a, 'b when 'e :> IEnumerator<'a>> (count: int64) (e: 'e) = new TakeEnumerator<_,_>(e, count)

